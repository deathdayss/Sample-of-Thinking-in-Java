## 9. Holding Your Object

### Generics and type-safe containers

Here, a special Java SE5 annotation is used to suppress the warning. Annotations start with an ‘@’ sign, and can take an argument; this one is **@SuppressWarnings** and the argument indicates that "unchecked" warnings only should be suppressed:

```java
class Apple {
    private static long counter;
    private final long id = counter++;
    public long id() { return id; }
}
class Orange {}
public class ApplesAndOrangesWithoutGenerics {
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
        ArrayList apples = new ArrayList();
        for(int i = 0; i < 3; i++)
            apples.add(new Apple());
        // Not prevented from adding an Orange to apples:
        apples.add(new Orange());
        for(int i = 0; i < apples.size(); i++)
            ((Apple)apples.get(i)).id();
        // Orange is detected only at run time
    }
} /* (Execute to see output) *///:~
```

### Basic concepts

The Java container library takes the idea of "holding your objects" and divides it into two distinct concepts, expressed as the basic interfaces of the library:

1. **Collection**: a sequence of individual elements with one or more rules applied to them. A *List* must hold the elements in the way that they were inserted, a Set cannot have duplicate elements, and a **Queue** produces the elements in the order determined by a queuing discipline (usually the same order in which they are inserted).
2. **Map**: a group of key-value object pairs, allowing you to look up a value using a key. An **ArrayList** allows you to look up an object using a number, so in a sense it associates numbers to objects. A map allows you to look up an object using another object. It’s also called an **associative array**, because it associates objects with other objects, or a dictionary, because you look up a value object using a key object just like you look up a definition using a word. **Maps** are powerful programming tools.

The **Collection** interface generalizes the idea of a sequence—a way of holding a group of objects. Here’s a simple example that fills a Collection (represented here with an **ArrayList**) with **Integer** objects and then prints each element in the resulting container:

```java
import java.util.*;

public class SimpleCollection {
    public static void main(String[] args) {
        Collection<Integer> c = new ArrayList<Integer>();
        for(int i = 0; i < 10; i++)
            c.add(i); // Autoboxing
        for(Integer i : c)
            System.out.print(i + ", ");
    }
} /* Output:
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
*///:~
```

### Adding groups of elements

There are utility methods in both the **Arrays** and **Collections** classes in **java.util** that add
groups of elements to a **Collection. Arrays.asList( )** takes either an array or a commaseparated list of elements (using varargs) and turns it into a **List** object.
**Collections.addAll( )** takes a **Collection** object and either an array or a comma-separated
list and adds the elements to the **Collection**. Here’s an example that shows both methods, as well as the more conventional **addAll( )** method that’s part of all **Collection** types:

```java
// Adding groups of elements to Collection objects.
import java.util.*;
public class AddingGroups {
    public static void main(String[] args) {
        Collection<Integer> collection =
                new ArrayList<Integer>(Arrays.asList(1, 2, 3, 4, 5));
        Integer[] moreInts = { 6, 7, 8, 9, 10 };
        collection.addAll(Arrays.asList(moreInts));
        // Runs significantly faster, but you can’t
        // construct a Collection this way:
        Collections.addAll(collection, 11, 12, 13, 14, 15);
        Collections.addAll(collection, moreInts);
        // Produces a list "backed by" an array:
        List<Integer> list = Arrays.asList(16, 17, 18, 19, 20);
        list.set(1, 99); // OK -- modify an element
        // list.add(21); // Runtime error because the
        // underlying array cannot be resized.
    }
} ///:~
```

However, **Collections.addAll( )** runs much faster, and it’s just as easy to construct the **Collection** with no elements and then call **Collections.addAll( )**, so this is the preferred approach.

The **Collection.addAll( )** member method can only take an argument of another **Collection** object, so it is not as flexible as **Arrays.asList( )** or **Collections.addAll( )**, which use variable argument lists.

It’s also possible to use the output of **Arrays.asList( )** directly, as a **List**, but the underlying representation in this case is the array, which cannot be resized. If you try to **add( )** or **delete( )** elements in such a list, that would attempt to change the size of an array, so you’ll get an "Unsupported Operation" error at run time.

A limitation of **Arrays.asList( )** is that it takes a best guess about the resulting type of the **List**, and doesn’t pay attention to what you’re assigning it to. Sometimes this can cause a problem:

```java
import java.util.Collections;
import java.util.List;

class Snow {}
class Powder extends Snow {}
class Light extends Powder {}
class Heavy extends Powder {}
class Crusty extends Snow {}
class Slush extends Snow {}
public class AsListInference {
    public static void main(String[] args) {
        List<Snow> snow1 = Arrays.asList(
                new Crusty(), new Slush(), new Powder());
        // Won’t compile:
        // List<Snow> snow2 = Arrays.asList(
        // new Light(), new Heavy());
        // Compiler says:
        // found : java.util.List<Powder>
        // required: java.util.List<Snow>
        // Collections.addAll() doesn’t get confused:
        List<Snow> snow3 = new ArrayList<Snow>();
        Collections.addAll(snow3, new Light(), new Heavy());
        // Give a hint using an
        // explicit type argument specification:
        List<Snow> snow4 = Arrays.<Snow>asList(
                new Light(), new Heavy());
    }
} ///:~
```

When trying to create **snow2**, **Arrays.asList( )** only has types of **Powder**, so it creates a **List<Powder>** rather than a **List<Snow>**, whereas **Collections.addAll( )** works fine because it knows from the first argument what the target type is.

As you can see from the creation of **snow4**, it’s possible to insert a "hint" in the middle of **Arrays.asList( )**, to tell the compiler what the actual target type should be for the resulting **List** type produced by **Arrays.asList( )**. This is called an *explicit type argument specification*.